{"meta":{"title":"橙子前端","subtitle":null,"description":null,"author":"橙 子","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2018-09-27T07:10:36.220Z","updated":"2018-09-27T07:10:36.220Z","comments":true,"path":"2018/09/27/hello-world/","link":"","permalink":"http://yoursite.com/2018/09/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"","slug":"javascript","date":"2018-09-27T07:10:36.220Z","updated":"2018-09-27T07:10:36.220Z","comments":true,"path":"2018/09/27/javascript/","link":"","permalink":"http://yoursite.com/2018/09/27/javascript/","excerpt":"","text":"javascript常用方法 获取DOM的children firstChild除了会获取到dom节点，还会获取到之间的空格（代码未压缩）firstElementChild会获取到第一个dom子节点常规的方法是使用children 获取到DOM的CSS样式 直接使用dom.style.property，只适合行内样式使用getComputedStyle(element, null|’’|:before|:after)","categories":[],"tags":[]},{"title":"typescript","slug":"typescript","date":"2018-09-20T09:02:52.000Z","updated":"2018-09-27T07:10:36.220Z","comments":true,"path":"2018/09/20/typescript/","link":"","permalink":"http://yoursite.com/2018/09/20/typescript/","excerpt":"","text":"typescrpt(以下简称为ts)是js的超集。ts扩展了JavaScript的语法， 一、数据类型1. number 1const num:number = 123; 2. string 1const str:string = &apos;this is a numebr&apos; 3. boolean 1const flag:boolean = true; 4. undefined 1const undef:undefined = undefined; 5. null 1const vo:null = null 以上跟之前的es5(6)使用一样 6. array 声明方式有两种+一种 123const arr:Array&lt;number&gt; = [1,2,3,4]const arr2:string[] = [&apos;123&apos;,&apos;2&apos;,&apos;3&apos;]const arr3:any[] = [&apos;123&apos;,22,true] 7. 元组 听名字就可以联想到数组，它属于数组 123const tuple:[number, string] = [123, &apos;this is ts&apos;];const arr:Array&lt;[number, string]&gt; = [[123, &apos;this is ts&apos;]] 8. 枚举 12345678910111213/*enum 枚举名&#123; 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数], &#125;;*/enum Flag &#123; success = 1, error = 2 &#125;let flag:Flag = Flag.success // 1// 可以应用于状态码// 如果标识符没有赋值，那么它的值就是下标// 标识符可以带字符串或者不带，eg: success, &apos;success&apos; 9. void typescript中的void表示没有任何类型，一般用于定义方法的时候方法没有返回值123function run():void &#123; // 这里不能写undefined console.log(&apos;run&apos;)&#125; 10. never 是其他类型(包括null和undefined)的子类型，代表从不会出现的值 11. any 任意类型，不容限制就跟es5中的变量一样了 二、函数 函数的定义 es5中定义函数有两种，函数声明式和函数表达式 1234567// 参数要写类型，返回值也要写类型function getInfo(name:string, age:number):string &#123; return `&#123;$name&#125; --- $&#123;age&#125;`;&#125;const getInfo2 = (name:string, age:number):string &#123; return `&#123;$name&#125; --- $&#123;age&#125;`;&#125; 可选参数 es5里面实参和形参可以不一样，但是ts必须一样，如果不一样就需要配置可选参数(必须配置到参数的最后面) 1234567function getIfno(name:string, age?:number):string &#123; return age ? `$&#123;name&#125; === $&#123;age&#125;` : `$&#123;name&#125; === 年龄保密`&#125;alert(getInfo(&apos;zhangsan&apos;));alert(getInfo(&apos;zhangsan&apos;, 123)); 默认参数 es5中没有，es6和ts中有 1234567function getInfo(name:string, age:number = 20):string &#123; return age ? `$&#123;name&#125; === $&#123;age&#125;` : `$&#123;name&#125; === 年龄保密`&#125;alert( getInfo(&apos;张三&apos;));alert( getInfo(&apos;张三&apos;,30)); 剩余参数（扩展运算符） 1234567function sum(a:number, b:number, c:number, d:number):number &#123; return a + b + c + d&#125;// 以下是简写function sum2(...res:number[]):number &#123; return res.reduce((a, b) =&gt; a + b, 0)&#125; 函数重载 java中方法的重载：是指两个或两个以上的同名函数，但它们参数不一样，这时会出现函数重载的情况。ts中的重载：通过为同一个函数提供多个函数类型定义来试下多种功能的目的。 1234567891011121314151617181920// es5中出现同名函数会覆盖function getInfo(name:string):string;function getInfo(age: number):string;function getInfo(str:any):any&#123; if (typeof str === &apos;string&apos;) &#123; return `我叫：$&#123;str&#125;` &#125; else if (typeof str === &apos;number&apos;) &#123; return `我的年龄:$&#123;str&#125;` &#125;&#125; //function getInfo(name:string):string;function getInfo(name:string, age:number):string;function getInfo(name:any, age?:any):any &#123; /* 一系列操作 */&#125; 箭头函数 同es6 三、类 ES5的类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 1. 简单类function Person() &#123; this.name = &apos;张三&apos;; this.age = 22;&#125;const p = new Person()// 2. 构造函数和原型链里面增加方法function Person() &#123; this.name = &apos;张三&apos;; this.age = 20; this.run = function() &#123; alert(`$&#123;this.name&#125;在运动`) &#125;&#125;// 3. 原型链上面的属性会被多个实例共享 构造函数不会Person.prototype.sex = &apos;男&apos;Person.prototype.work = function() &#123; alert(`$&#123;this.name&#125;在工作`)&#125;// 4. 静态方法Person.getInfo = function() &#123; // 静态方法&#125;// 5. 继承 对象冒充实现继承function Web() &#123; Person.call(this)&#125;const w = new Web()w.run() // 可以继承构造函数里面的方法w.work() // 没法继承原型链的方法// 6. 原型链继承function Web() &#123;&#125;Web.prototype = &#123; constructor: Person,&#125;// 或写成// Web.prototype = new Person()// 这种无法传参// 7. 原型链+对象冒充组合继承模式function Person(name, age) &#123; this.name = name; this.age = age; this.run = function() &#123; // &#125;&#125;Person.prototype.sex = &apos;男&apos;Person.prototype.work = function() &#123; //&#125;function Web(name, age) &#123; Person.call(this, name, age)&#125;Web.protoType = new Person();、、、 Typescript中的类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// 1. 定义class Person &#123; name:string; // 属性，前面省略了public关键词 constructor(name:string) &#123; this.name = name; &#125; run():void &#123; alert(this.name); &#125; getName():string &#123; return this.name; &#125; setName(name:string):void &#123; this.name = name &#125;&#125;const p = new Person(&apos;zhangsan&apos;)p.run()// 2. 继承 class Student extends Person &#123; constructor(name:string)&#123; super(name) &#125; run():string() &#123; return `$&#123;this.name&#125;在运动-子类` &#125; work():void &#123; alert(`$&#123;this.name&#125;在工作`) &#125;&#125;// 3. 修饰符/*public: 公有(默认) 在当前类里面、子类、类外面都可以访问protected: 保护 在当前类里面、子类里面可以访问，在类外部没法访问private: 私有 在当前里面可以访问，子类、类外部都没法访问*/// 4. 静态属性 静态方法class Per &#123; public name:string; public age:number = 20; static sex = &apos;男&apos; // 静态属性 constructor(name:string) &#123; this.name = name &#125; run() &#123; alert(`$&#123;this.name&#125;在运动`) &#125; work() &#123; alert(`$&#123;this.name&#125;在工作`) &#125; static print() &#123; // 静态方法，无法调用类里面的属性 alert(`print方法$&#123;Per.sex&#125;`) &#125;&#125;// 5. 多态// 父类定义一个方法不去实现，让继承它的子类去实现，每个子类有不同的表现class Animal &#123; name:string; constructor(name:string) &#123; this.name = name; &#125; eat() &#123;&#125;&#125;class Dog extends Animal &#123; constructor(name:string) &#123; super(name) &#125; eat() &#123; return this.name + &apos;吃粮食&apos; &#125;&#125;class Cat extends Animal &#123; constructor(name:string) &#123; super(name) &#125; eat() &#123; return this.name + &apos;吃老鼠&apos; &#125;&#125;// 抽象类/*提供其他类继承的基类，不能直接被实例化。用abstract关键词定义抽象类和抽象方法，抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。abstract抽象方法只能放在抽象类中，抽象类和抽象方法用来定义标准。*/abstract class Animal &#123; public name:string; constructor(name:string) &#123; this.name = name &#125; abstract eat():any &#123;&#125; run():void &#123; /*...*/ &#125;&#125; 四、接口 作用：在面向对象的编程中，接口是一种规范的定义，它定义了行为和动作的规范，在程序设计里面，接口起到一种限制和规范的作用。接口定义了某一批类所需要遵守的规范，接口不关心这些类的内部状态数据，也不关心这些类方法的实现细节，它只规定这批类里必须提供某些方法，提供这些方法的类就可以满足实际需要。接口类似于java，同时还增加了更灵活的接口类型，包括属性、函数、可索引和类等。 属性类接口 12345678910111213141516171819202122function printLabel():void &#123;&#125;printLabel()function printLabel(label:string):void &#123;&#125;printLabel(&apos;this is ts&apos;)// ts中自定义方法传入参数，对json进行约束function printLabel(labelInfo:&#123; label:string&#125;):void &#123;&#125;//printLable(&apos;hhah&apos;) // 错误//printLable(&#123;name: &apos;123&apos;&#125;) // 错误printLable(&#123;lable: &apos;123&apos;&#125;) // 正确interface FullName &#123; firstName: string; secondName?: string;&#125;function printName(name:FullName):void &#123; const &#123; firstName, secondName &#125; = name; console.log(`$&#123;firstName&#125; -- $&#123;secondName&#125;`);&#125; 函数类型接口 对方法传入的参数 以及返回值进行约束 123456interface encrypt &#123; (key:string, value:string):string;&#125;var md5:encrypt = function(key:string, value:string):string &#123; return key + value&#125; 可索引接口 数组、对象的约束（不常用） 123456789interface UserArr &#123; [index:number]:string&#125;var arr:UserArr = [&apos;aaa&apos;, &apos;bbb&apos;];interface UserObj &#123; [indx:string]:string&#125;var arr:UserObj = &#123; name: &apos;张三&apos; &#125; 类类型接口 对类的约束和抽象类抽象相似 12345678910111213interface Animal &#123; name:string; eat(str:string):void&#125;class Dog implements Animal &#123; name:string; constructor(name:string) &#123; this.name = name; &#125; eat(food:string) &#123; console.log(`$&#123;this.name&#125;吃$&#123;food&#125;`) &#125;&#125; 接口扩展 接口可以继承接口 123456789101112131415161718interface Animal &#123; eat():void;&#125;interface Person extends Animal &#123; work():void;&#125;class Web implements Person &#123; public name:string; constructor(name:string) &#123; this.name = name; &#125; eat() &#123; console.log(`$&#123;this.name&#125;...`) &#125; work() &#123; console.log(`$&#123;this.name&#125;...`) &#125;&#125; 五、泛型 定义 软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。组件不仅能够支持当前的数据类型，同时也要支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。在像C#和Java面向语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。这样用户就可以以自己的数据类型来使用组件。通俗理解：泛型就是解决类、接口、方法的复用性、以及对不特定数据类型的支持（类型校验） 函数 123456789101112function getData(value:string):string &#123; return value&#125;// 同时返回string类型和number类型，就需要写两个函数// any可以解决这个问题，any放弃了类型检查，传入什么，返回什么。如果设置返回值的类型，就可以解决。// 泛型:可以支持不特定的数据类型，要求传入的参数和返回的参数一致// T表示泛型，具体什么类型是调用这个方法的时候决定的function getData&lt;T&gt;(value: T):T &#123; return value&#125;getData&lt;string&gt;(&apos;类型一致 string&apos;); 类 123456789101112131415// 比如有个最小堆算法，需要同时支持返回数字和字符串 a-z两种类型class MinClass&lt;T&gt; &#123; public list:T[] = []; add(value:T):void &#123; this.list.push(value) &#125; min():T &#123; const minNum = this.list[0]; for(let i = 0; i &lt; this.list.length; i++) &#123; minNum &gt; this.list[i] &amp;&amp; minNum = this.list[i]; return minNum; &#125; &#125;&#125;var m1 = new MinClass&lt;number&gt;(); 接口 123456interface ConfigFn &#123; &lt;T&gt;(value: T):T;&#125;const getdata:ConfigFn = function&lt;T&gt;(value:T):T &#123;return value&#125;","categories":[],"tags":[{"name":"typescript javascript","slug":"typescript-javascript","permalink":"http://yoursite.com/tags/typescript-javascript/"}]},{"title":"axios统一异常处理","slug":"axios统一异常处理","date":"2018-09-10T15:44:19.000Z","updated":"2018-09-27T07:10:36.220Z","comments":true,"path":"2018/09/10/axios统一异常处理/","link":"","permalink":"http://yoursite.com/2018/09/10/axios统一异常处理/","excerpt":"","text":"在前端中我们经常会遇到接口异常的情况，可能是请求异常，或者是响应异常，这个时候需要友好的处理。对应响应来说，针对于不同的接口可能会对应返回不同的状态码，而有些异常状态码（如401，203）是共有的，并且处理操作还一样，那么统一放在一块处理甚好。 介绍一下axios的interceptors 拦截器，可以截取请求或响应,在then或catch处理前 1234567891011121314151617 // 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); 当然也可以随时移除拦截器，如下 1axios.interceptors.(request|response).eject(/*...*/) 统一处理异常代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071axios.interceptors.response.use(response =&gt; &#123; const data = response.data // 根据返回的code值来做不同的处理(和后端约定) switch (data.msg) &#123; case &apos;201&apos;: toast.error(&apos;系统异常，即将重新登录&apos;, &#123; position: toast.POSITION.BOTTOM_CENTER, pauseOnHover: false, hideProgressBar: true, &#125;) sessionStorage.clear() Cookies.remove(&apos;name&apos;, &#123; path: &apos;&apos; &#125;) history.push(&apos;/&apos;) break case &apos;202&apos;: case &apos;203&apos;: case &apos;204&apos;: case &apos;205&apos;: // 操作失败 toast.error(data.result, &#123; position: toast.POSITION.BOTTOM_CENTER, pauseOnHover: false, hideProgressBar: true, &#125;) break case &apos;206&apos;: case &apos;207&apos;: // 系统错误 toast.error(&apos;系统异常，即将重新登录&apos;, &#123; position: toast.POSITION.BOTTOM_CENTER, pauseOnHover: false, hideProgressBar: true, &#125;) sessionStorage.clear() Cookies.remove(&apos;name&apos;, &#123; path: &apos;&apos; &#125;) history.push(&apos;/&apos;) break case &apos;208&apos;: case &apos;209&apos;: case &apos;210&apos;: case &apos;211&apos;: case &apos;213&apos;: case &apos;214&apos;: case &apos;215&apos;: case &apos;216&apos;: case &apos;217&apos;: case &apos;218&apos;: case &apos;219&apos;: // 系统错误 toast.error(data.result, &#123; position: toast.POSITION.BOTTOM_CENTER, pauseOnHover: false, hideProgressBar: true, &#125;) break default: return response &#125; return response&#125;, (err) =&gt; &#123; // 这里是返回后端代码错误处理（500 etc.） toast.info(err.toString(), &#123; position: toast.POSITION.BOTTOM_CENTER, pauseOnHover: false, hideProgressBar: true, &#125;) return Promise.resolve(err)&#125;) VUE可以使用import { Message } from &#39;iview&#39;;代替toast 以上就差不多了。 补充：因为之前我对axios的不’规范’书写（axios.post(url, data, config)）,简写方式也不是不能用，但是这样也缺少了扩展性，比如说以下代码：1234567891011121314151617181920export const postRequest = (url, params) =&gt; &#123; let accessToken = getStore(&quot;accessToken&quot;); // 获取token return axios(&#123; method: &apos;post&apos;, url: `$&#123;base&#125;$&#123;url&#125;`, //base为统一前缀，也可以设置baseURL data: params, transformRequest: [function (data) &#123; //允许在向服务器发送前，修改请求数据 let ret = &apos;&apos;; for (let it in data) &#123; ret += encodeURIComponent(it) + &apos;=&apos; + //encodeURIComponent 编码 encodeURIComponent(data[it]) + &apos;&amp;&apos;; &#125; return ret; &#125;], headers: &#123; // 设置请求头 &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;, &apos;accessToken&apos;: accessToken //这里设置默认参数 &#125; &#125;);&#125;; 这里网上摘抄的一段，注释以上。如果简写，那么这么精彩的配置，那就不适合了。介绍一下上文的transformRequest, 只能只能用在 ‘PUT’, ‘POST’ 和 ‘PATCH’ 这几个请求方法， 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream 这里是为了后端可以接受数组","categories":[],"tags":[]},{"title":"React合成事件和DOM原生事件","slug":"React合成事件和DOM原生事件","date":"2018-09-06T08:56:03.000Z","updated":"2018-09-27T07:10:36.220Z","comments":true,"path":"2018/09/06/React合成事件和DOM原生事件/","link":"","permalink":"http://yoursite.com/2018/09/06/React合成事件和DOM原生事件/","excerpt":"","text":"首先我们在jsx绑定的事件，都是委托在document上，当事件发生并冒泡到document时，React将事件内容封装并交由真正的处理函数运行。 封装：合成事件的Event并不是原生Event，而是封装的一层。合成事件层（中间层）：SyntheticEvent，避免DOM绑定过多的事件处理函数，整个页面响应以及内存占用受到影响，而且还兼容不同浏览器之间的事件系统差异。Event对象，合成事件的Event是复用的，所以在事件处理函数执行完之后，属性都会被清空，所以event的属性无法被异步访问。 冒泡响应顺序 原生事件先响应，合成事件后响应。 阻止冒泡 evt.stopPropagtion() 如果在合成事件内调用，那么只能阻止合成事件之前的冒泡，不能阻止原生事件。 如果在原生事件调用，那么会阻止吊所有的合成事件执行。 evt.nativeEvent.stopImmediatePropagation() evt.nativeEvent是原生Event对象，但是作用不大，这个函数只能阻止document上的事件监听器。其中还要注意事件绑定顺序问题，如果在ReactDOM.render之前绑定的document事件，那么是无法阻止的（这种情况一般不会发生）。 事件捕获合成事件的代理在document只注册冒泡阶段的事件监听器。代理内部会有一个path，path的顺序是从child到parent，注册所有的事件监听函数，captured和bubbled都会进行标记，等到执行的时候，如果是captured的话，那么执行顺序就是从后到前，如果是bubbled的话，那么执行顺序是从前到后","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"精禾项目","slug":"精禾项目","date":"2018-09-05T09:32:15.000Z","updated":"2018-09-27T07:10:36.220Z","comments":true,"path":"2018/09/05/精禾项目/","link":"","permalink":"http://yoursite.com/2018/09/05/精禾项目/","excerpt":"","text":"flex布局12345display: flex|inline-flex; //声明flex布局flex-direction: column|row(default)|column-reserve|row-reserve; // 主轴方向justify-content: space-between|space-around|center|flex-start|flex-end; // 主轴方法的布局align-items: center|flex-start|flex-end; // 次轴的布局// 子元素 CSS单位使用先说结论 拥抱和使用相对单位，让页面结构去定义样式代码的含义 个人喜好对字号使用rem，选择性地对页面组件的一些简单缩放效果使用em(padding、width、height或border-radius,border使用px) 你可以让整个页面实现响应式缩放，而不需要任何媒体查询（body的font-size使用rem） 在声明行高时，使用不带单位的数值 开始了解和使用CSS最新的特性之一-自定义属性吧！ em的基准值是当前元素的字号大小，所以设置em为不是font-size的属性时，基准是font-size。 当对font-size使用em时，在font-size上的em会先从继承到的字号大小衍生出来的。 当在一个元素使用em同时声明font-size和其他属性，其它属性会基于font-size(calc之后的)进行计算。 em列表嵌套使用，可能会导致字体越来越小或者越来越大，解决方法 123456ul &#123; font-size: .8em;&#125;ul ul &#123; font-size: 1em;&#125; 最好还是写一个css选择器。 停止使用像素思维来思考，默认字体该是多少就是多少，不要设置为10px。 调整单个组件的大小，请用rem。 如果要使用vw在font-size则使用calc吧。 当一个元素是用带单位的值声明的，那么它的后代元素会继承计算结果值 动画正则表达式","categories":[],"tags":[]},{"title":"travis","slug":"travis","date":"2018-09-04T18:01:14.000Z","updated":"2018-09-27T07:10:36.220Z","comments":true,"path":"2018/09/04/travis/","link":"","permalink":"http://yoursite.com/2018/09/04/travis/","excerpt":"","text":"费了一天时间终于把Travis搞明白了，生命在于折腾 hexo的弊端 hexo每次更新文章，都特别的繁琐，必须经历以下命令 123hexo cleanhexo generatehexo deploy 看起来特别麻烦，如果当我们更改好文章，push到github上之后，能自动执行上面代码，这样会优化很多不必要的时间 Travis CI工具 针对于以上的弊端，Travis CI工具可以很好的解决。首先Travis CI提供了持续集成服务，其实这里并没有用到它的CI服务，而是通过监听分支提交的动态，在集成成功后执行自定义的部署逻辑。 持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。 网上教程很多，首先，你需要两个分支，一是主开发分支（dev），二是生成环境分支（gh-pages） 首先，我们从0开始搭建hexo 安装git 安装node（npm）或者yarn 全局安装hexo 新建文件夹并cd到文件夹，git init创建git环境 新建分支dev，在dev分支上初始化hexo 生成public文件 新建分支gh-pages，把public的内容放到该分支下 在github上面新建你的仓库 在setting选项中，选择你的github pages分支 现在就好了，其中可能注意几个地方如下 文件夹根目录下的_config.yml，需要修改repo里面的信息 github Pages会存在二级目录，所以需要设置 这里就搭建好hexo了，现在开始搞Travis首先在dev分支的根目录下新建一个.travis.yml这里有一个样本12345678910111213141516171819202122232425262728293031323334353637language: node_jsnode_js: stableaddons: # Travis CI建议加的，自动更新api apt: update: truecache: directories: - node_modules # 缓存 node_modulesinstall:- npm install # 初次安装，在CI环境中，执行安装npm依赖# before_script: script:- hexo g # 执行 hexo generate，把文章编译到public中after_success: # 执行script成功后，进入到public，把里面的代码提交到博客的gh-pages分支- cd ./public- git init- git config user.name &quot;Yuying Wu&quot;- git config user.email &quot;wuyuying1128@gmail.com&quot;- git add .- git commit -m &quot;Update site&quot;- git push --force --quiet &quot;https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:gh-pagesbranches: only: - dev # CI 只针对分支 devenv: global: # 全局变量，上面的提交到github的命令有用到 - GH_REF: github.com/YuyingWu/blog.git - secure: # secure是自动生成的，执行`travis encrypt &apos;GH_TOKEN=$&#123;your_github_personal_access_token&#125;&apos; --add` 其中解释一下最后一段注释，github提交需要github access token的生成和加密这里有另外一个简便方法，但都需要github access token 首先生成github的Personal Access Tokens记住你的token码 安装Travis CI 1gem install travis 加密登陆一下（travis login），输入github的用户名密码，然后再执行1travis encrypt &apos;GH_TOKEN=$&#123;your_github_personal_access_token&#125;&apos; --add 这里执行之后，会发现.travis.yml文件会刷新，并生成env.global.secure的值 登陆Travis CI的官网，登陆github，找到对应的项目仓库，打开它然后每次当你git push dev分支的内容，Travis就会自动化执行，并刷新到github仓库的gh-pages分支。神奇！！！！","categories":[],"tags":[]},{"title":"requestAnimationFrame","slug":"requestAnimationFrame","date":"2018-09-04T16:57:07.000Z","updated":"2018-09-27T07:10:36.220Z","comments":true,"path":"2018/09/04/requestAnimationFrame/","link":"","permalink":"http://yoursite.com/2018/09/04/requestAnimationFrame/","excerpt":"","text":"","categories":[],"tags":[]}]}